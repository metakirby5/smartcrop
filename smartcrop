#!/usr/bin/env python2

from sys import argv, exit
from itertools import chain
from PIL import Image
from numpy import array
from scipy.cluster.vq import kmeans2
from colorsys import rgb_to_hsv, hsv_to_rgb

tw = 200

def get_colors(img):
    w, h = img.size
    return list(chain(*(
        [color] * count for count, color in img.getcolors(w * h)
    )))

def clusterize(img, k):
    clusters, labels = kmeans2(array(img.getdata()), k, minit='points')
    img.putdata([tuple(clusters[label]) for label in labels])

def tobits(img):
    clusters, labels = kmeans2(array(img.getdata()), 2, minit='points')
    return labels

def flatten(bits, majo, mino):
    return [sum(bits[imin*majo+imaj] for imin in range(mino))
            for imaj in range(majo)]

def get_offset(arr, win):
    best = win * win # > max dist
    offset = 0
    for i in range(len(arr) - win + 1):
        count = sum(arr[i:i+win])
        # distance from half of the max count
        cur = abs((win * win / 2) - count)
        if cur < best:
            best = cur
            offset = i
    return offset

def main():
    if len(argv) != 3:
        print('USAGE: %s [src] [dest]' % argv[0])
        exit()

    _, src, dest = argv

    img = Image.open(src)
    iw, ih = img.size
    isiz = min(iw, ih)

    thumb = img.copy()
    th = int(tw * (ih / float(iw)))
    thumb.thumbnail((tw, th))

    bits = tobits(thumb)
    xmajo, mino, majo = tw > th, min(tw, th), max(tw, th)
    toffset = get_offset(flatten(bits, majo, mino), mino)

    ioffset = int(toffset * (iw / float(tw)))
    # correct the offset if it's out of bounds
    if ioffset + isiz > iw:
        ioffset = iw - isiz

    print 'o: %s; (%s, %s)' % (ioffset, iw, ih)

    if xmajo:
        crop = img.crop((ioffset, 0, ioffset + isiz, isiz))
    else:
        crop = img.crop((0, ioffset, isiz, ioffset + isiz))

    crop.save(dest)

if __name__ == '__main__':
    main()
